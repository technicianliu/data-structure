一：树的定义和表示
    基本术语：
             （1），结点拥有的子树数目称为结点的度，树的度称为树中结点度的最大值
             （2），叶子叫做终端结点
             （3），深度和高度，树中结点的最大层次称为树的深度。高度的定义是：叶子结点的高度为零，非叶子结点的高度等于
                    它的子女结点高度的最大值加1，这样树的高度就是根结点的高度。深度和高度数值相同
             （4），森林：是m棵互不相交的树的集合。在数据结构中，树和森林的概念相近，删去一棵树的根结点，便得到一个森林；
                    加上一个结点作为森林中所有树的根结点，森林就变为一棵树。
                    
二：树和森林：  
    存储表示：（博客中有图形表示）
            （1），父指针表示法（在Huffman树当中用到了这个表示方法）
                   用一组连续空间存储输的结点，同时在每个结点中附设一个指示器指示其双亲结点在表中的位置（指示器是一个整
                   数值，代表某个序号）。
             （2），子女链表表示法，采用多重链表，每个结点有多个指针域，其中每个结点指向一棵子树的根结点，其中每个子树
                   指向一棵子树的根结点，即把每个孩子排列成指针链表。子女链表表示法是一个链表向量。
                   每个链表有两部分组成：
                   <1>孩子结点：其数据域存放双亲结点的孩子结点在向量中的序号，指针域存放双亲结点下一个孩子的链接地址。
                   <2>头结点：其数据域存放结点的值，指针域存放第一个孩子的链接地址。
             （3），子女-兄弟链表表示法：用二叉树链表做数据结构。这种结构的优点是：它和二叉树的二叉链表表示完全一样，可以
                    用二叉树的算法来实现对树的操作。这个表示法的树中查找父结点的算法有点难。
             （4），树的子女-兄弟链表表示法与二叉树的二叉链表表示完全一样，因此，可以将一棵树转化为二叉树：
                    <1>,在所有兄弟结点之间加一连线；
                    <2>,对每个结点除了保留与其长子的连线外，去掉该结点与其他孩子的连线；
                    <3>,将兄弟连线顺时针旋转45度。
             （5），把森林转化为二叉树的方法：
                    <1>,把森林中的每棵树变为二叉树；
                    <2>,因为转换所得的二叉树的根结点的右子树均为空，故可将各二叉树的根结点视为兄弟从左至右连在一起，就形成了
                        一棵二叉树。（我怎么觉得是右边的根依次作为左边的右儿子）。
             （6），把二叉树转化为树的方法是：
                    <1>,把每个结点的右链上的结点与结点的双亲加上连线；
                    <2>,去掉每个结点右链上的连线；
                    <3>,将兄弟连线逆时针旋转45度。
             （7），将二叉树转化为森林的方法是：
                    <1>,断开根结点出发的所有的右链连线（有多少右链就说明森林中有多少树）；
                    <2>,将断开后的每棵树转化为二叉树；
    
    树和森林的遍历：树和森林的遍历分为深度优先遍历和广度优先遍历两种遍历方式。
              假设树T={root,T1,T2,T3,...,Tm},树的深度优先遍历为：
              （1），树的先根遍历
                   <1>,若树T非空，先访问树的根结点root；
                   <2>,依次先根遍历T的每棵子树T1,T2,T3,T4,...,Tm;
              （2），后根遍历
                   <1>,若树T非空，先依次后根遍历T每棵子树T1,T2,T3,...,Tm;
                   <2>,然后访问T的根结点root。
               树的广度优先遍历（分层进行访问）：
                    先访问树的根结点，然后自左向右依次遍历根的每棵子树，直到所有结点都访问完毕。（简单说就是层次遍历）

三，最优二叉树：
             （1），基本概念：
                   <1>,树的路径长度是从树根到树中每一结点的路径长度之和。在结点数目相同的二叉树中，完全二叉树的路径长度最短
                   <2>,树的带权路径长度：
                       结点的权：在一些应用中赋予树中结点的一个有某种意义的实数。
                       结点的带权路径长度：结点到树根之间的路径长度与该结点上权的乘积。
                       树的带权路径长度：树中所有叶结点的带权路径长度之和。
                   <3>,最优二叉树：
                       在权为w1,2,w3,...,wn的n个叶子所构成的所有二叉树中，带权路径长度最小的二叉树称为最优二叉树
                       最优二叉树中，权越大的叶子离根越近。
            （2），最优二叉树的构造：
                   <1>,根据给定的n个权值w1,w2,w3,..,wn构成n棵二叉树的森林F={T1,T2,T3,...,Tn},其中每棵二叉树Ti中都只有一个
                   权值为wi的根结点，其左右子树均空。
                   <2>,在森林F中选出两棵根结点权值最小的树（当这样的树不只两棵时，可以从中任选两棵），将这两棵树合并为一个
                   新树，为了保证新树仍是二叉树，需要增加一个新结点作为新树的根，并将所选的两棵树的根分别作为新根的左右孩子
                   （谁左谁右无关紧要，不影响带权路径长度），将这两个孩子的权值之和作为新树根的权值。
                   <3>,对新的森林F重复<2>,直到F中剩下一棵树为止。这棵树就是Huffman树。
                   <4>,n个叶子的Huffman树要经过n-1次合并，产生n-1个新结点。最终求得的Huffman树中有2n-1个结点，Huffman树是严格
                       二叉树，没有度为一的结点。
                   <5>,Huffman可以用链式存储结构，也可以用顺序存储结构。如果用链式存储结构，则在原有二叉树的基础上必须加上指针
                       双亲的指针parent，以便既可以执行双亲到孩子的操作，也可以执行从孩子到双亲的操作。
                       若是采用向量表示Huffman树中的结点集合，每个结点包括数据域data，带权结点权值weigh以及三个表示结点向量序号
                       的指示器（left存放左孩子结点在向量中的序号，right存放右孩子结点在向量中的序号以及parent存放双亲结点在向量
                       中的序号）。
                   <6>,因为字符集大小为n，故变长编码的长度不会超过n-1。 
                   


四，二叉树
             重要特性：
                    <1>,对任何非空二叉树，如果其终端结点数为n0，度为2的结点数为n2，则有n0=n2+1，由此可知，含有n个结点的二叉树有n-1个
                        空指针域。
                    <2>,完全二叉树：
                        对满二叉树自顶向下，同层自左向右连续编号，则深度为k有n个结点的二叉树，当且仅当每个结点都与深度为k的满二叉树
                        中的编号从1-n的结点一一对应，则称之为完全二叉树。在完全二叉树中，某个结点没有左孩子，则它一定没有右孩子，该结
                        点一定是叶子结点。
                    <3>,如果对一棵具有n个结点的完全二叉树的结点按层序编号，自顶向下，同层自左向右。则有：
                        如果i>1,则其双亲结点是i/2（不超过它的整数），它的左孩子是2*i，右孩子是2*i+1；
                        故若2*i>n，则结点无左孩子，若i*2+1>n,结点无右孩子；
                        若结点编号i为奇数，且i不等于1，它处于右兄弟位置，它的左兄弟为结点i-1,。若结点编号i为偶数，且i不等于n，它处于
                        左兄弟位置，它的右兄弟为i+1；（这些特点在构建顺序表存储的树时很有用）
                        
                        
                       
